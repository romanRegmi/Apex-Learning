When to Use SOC on Salesforce
If your app is process-centric or you are getting pushed to implement more complex calculations, validations, or richer UI experiences, you’ll be venturing into the land of Apex code. Salesforce provides many places to place Apex code, such as triggers, classes that include @AuraEnabled methods, APIs, batch Apex, and email handlers.

You can make a huge investment in developing and testing code, but it’s the business logic that you are most concerned about protecting. We explore some guidelines for writing business logic at a later time but for now consider the following instances for using SOC on Salesforce.

Replacing or adding another UI to your app — Consider how much code you need to rewrite or port that has nothing to do with the UI but affects your app’s inserting, updating, validating and calculating functionality.
Providing a public-facing API to your logic — Assess which parts of your existing code base you would call to implement the API. Is using your @AuraEnabled methods a good basis for an API? (The answer is no.)
Scaling your application logic via Batch Apex — If you need to continue to provide an interactive experience (for smaller volumes) via your existing UI, how would you share logic between the two to ensure that the user gets consistent results regardless of the size?
Working with complex logic in your Visualforce controllers or @AuraEnabled methods — Does any of your code deal with more than just handling information to and from the user? With Visualforce and Lightning Components, you can partition your code via Model–view–controller (MVC), a form of SOC for client development. However using controllers for all your code does not guarantee that you are following SOC in terms of your business logic.
Making it easy for new developers to find their way around your code base — How much time does a developer need to learn where to put new code and find existing behavior?